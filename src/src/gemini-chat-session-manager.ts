import { \n    GoogleGenerativeAI, \n    GenerativeModel, \n    Content, \n    Part, \n    ChatSession, \n    Tool,\n    FunctionResponsePart,\n    GenerateContentResponse\n} from \'@google/generative-ai\';\nimport { EXECUTE_TERMINAL_COMMAND_TOOL } from \'./ai-tools\'; // Assuming this is the correct path\n\nconst MAX_CHAT_HISTORY_LENGTH = 20; // Max number of Content objects in history\n\nexport class GeminiChatSessionManager {\n    private genAI: GoogleGenerativeAI | null = null;\n    private modelInstance!: GenerativeModel | null; // Definite assignment assertion\n    private currentChatSession: ChatSession | null = null;\n    private apiKey: string;\n    private modelName: string;\n    private chatHistory: Content[] = [];\n\n    constructor(apiKey: string, modelName: string) {\n        this.apiKey = apiKey;\n        this.modelName = modelName;\n        this.initializeSdkAndModel();\n    }\n\n    private initializeSdkAndModel() {\n        this.chatHistory = [];\n        this.currentChatSession = null;\n        if (this.apiKey) {\n            try {\n                this.genAI = new GoogleGenerativeAI(this.apiKey);\n                if (this.modelName && this.genAI) {\n                    this.modelInstance = this.genAI.getGenerativeModel({ \n                        model: this.modelName, \n                        tools: [EXECUTE_TERMINAL_COMMAND_TOOL] \n                    });\n                    this.startNewChatSession(); // Start a session immediately\n                } else {\n                    this.modelInstance = null;\n                }\n            } catch (error) {\n                console.error(\'Error initializing GoogleGenerativeAI or Model in ChatManager:\', error);\n                this.genAI = null;\n                this.modelInstance = null;\n            }\n        } else {\n            this.genAI = null;\n            this.modelInstance = null;\n        }\n    }\n\n    private startNewChatSession() {\n        if (!this.modelInstance) {\n            console.error(\'ChatManager: Model instance not available to start chat session.\');\n            this.currentChatSession = null;\n            return;\n        }\n        // Define the initial system prompt/context for the AI\n        const initialModelInstruction = `You are a helpful and friendly AI assistant integrated into a terminal application.\n        The user is on Windows 11.\n        Your primary goal is to assist with terminal commands and queries.\n        Instructions for your responses:\n        1. When providing command line examples or code snippets, encapsulate them in markdown code blocks.\n        2. For PowerShell commands, use \'\\\`\\\`\\\`powershell\' as the language identifier.\n        3. For other shell commands (e.g., cmd, bash), use \'\\\`\\\`\\\`sh\'.\n        4. ALWAYS provide commands on a single line; do not break them into multiple lines.\n        5. Keep your explanations concise and to the point.\n        6. If you decide to execute a command, you MUST use the \'execute_terminal_command\' tool.`;\n\n        this.chatHistory = [\n            { role: \"user\", parts: [{ text: initialModelInstruction }] },\n            { role: \"model\", parts: [{ text: \"Understood. I will follow these instructions and use the execute_terminal_command tool when appropriate.\" }] }\n        ];\n        this.currentChatSession = this.modelInstance.startChat({\n            history: this.chatHistory,\n            tools: [EXECUTE_TERMINAL_COMMAND_TOOL]\n        });\n    }\n\n    public updateCredentials(apiKey: string, modelName: string) {\n        const keyChanged = this.apiKey !== apiKey;\n        const modelChanged = this.modelName !== modelName;\n        this.apiKey = apiKey;\n        this.modelName = modelName;\n\n        if (keyChanged || modelChanged) {\n            this.initializeSdkAndModel(); // This will also start a new chat session\n        }\n    }\n\n    private addToHistory(content: Content) {\n        this.chatHistory.push(content);\n        if (this.chatHistory.length > MAX_CHAT_HISTORY_LENGTH) {\n            // Keep only the last MAX_CHAT_HISTORY_LENGTH items, preserving the initial system prompts if possible\n            // A more sophisticated history management might be needed for long conversations.\n            // For now, simple truncation, keeping the first 2 (system prompts) and last N-2.\n            const systemPrompts = this.chatHistory.slice(0, 2);\n            const recentHistory = this.chatHistory.slice(this.chatHistory.length - (MAX_CHAT_HISTORY_LENGTH - 2));\n            this.chatHistory = [...systemPrompts, ...recentHistory];\n        }\n        // Update the session\'s history if the SDK requires manual syncing (some versions do)\n        // For @google/generative-ai, sendMessage usually updates the session\'s internal history.\n    }\n\n    public async sendMessage(userQueryParts: Part[]): Promise<GenerateContentResponse | null> {\n        if (!this.currentChatSession) {\n            console.error(\'ChatManager: No active chat session.\');\n            // Attempt to re-initialize if possible\n            if (this.apiKey && this.modelName) {\n                this.initializeSdkAndModel();\n                if (!this.currentChatSession) return null;\n            } else {\n                return null;\n            }\n        }\n        try {\n            const userContent: Content = { role: \"user\", parts: userQueryParts };\n            this.addToHistory(userContent);\n            \n            // The sendMessage method of ChatSession takes the new message parts directly.\n            // The history is managed by the ChatSession instance itself.\n            const result = await this.currentChatSession.sendMessage(userQueryParts);\n            \n            if (result.response.candidates && result.response.candidates.length > 0) {\n                this.addToHistory(result.response.candidates[0].content); \n            }\n            return result.response;\n        } catch (error) {\n            console.error(\'ChatManager.sendMessage error:\', error);\n            // Consider removing the last user message from history if send failed\n            if (this.chatHistory.length > 0 && this.chatHistory[this.chatHistory.length -1].role === \"user\") {\n                this.chatHistory.pop();\n            }\n            throw error;\n        }\n    }\n\n    public async sendFunctionResponse(functionResponseParts: FunctionResponsePart[]): Promise<GenerateContentResponse | null> {\n        if (!this.currentChatSession) {\n            console.error(\'ChatManager: No active chat session for function response.\');\n            return null;\n        }\n        try {\n            // Add the function response to our managed history\n            // The role for function responses is typically \"function\" or \"tool\" in the Content object\n            this.addToHistory({ role: \"function\", parts: functionResponseParts });\n\n            // Send the function response parts to the ongoing chat\n            const result = await this.currentChatSession.sendMessage(functionResponseParts);\n            \n            if (result.response.candidates && result.response.candidates.length > 0) {\n                this.addToHistory(result.response.candidates[0].content);\n            }\n            return result.response;\n        } catch (error) {\n            console.error(\'ChatManager.sendFunctionResponse error:\', error);\n            throw error;\n        }\n    }\n}\n